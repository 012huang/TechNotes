操作系统的设计，可以归结为三点：

（1）以多进程形式，允许多个任务同时运行；

（2）以多线程形式，允许单个任务分成不同的部分运行；

（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。


# 进程

- 进程是运行中的程序，但是一个程序运行可能会产生多个进程。打开浏览器，这时会开启若干个进程；
- 每开启一个进程，CPU 就会给这个进程分配一块内存；
- 进程之间是相互独立的，内存是不共享的；


# 线程

- 一个进程包含若干个线程。比如音乐播放器，显示歌词是一个线程，播放音乐又是一个线程；
- 进程是一个容器，线程是此容器中的工作单位；
- 同一个进程中的多个线程是内存共享的。



# 进程和线程的区别

* **地址空间和其它资源**：进程间相互独立，同一个进程中的多个线程是内存共享的。某进程内的线程在其它进程不可见。
* **通信**：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
* **调度和切换**：线程上下文切换比进程上下文切换要快得多。

多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。


# 用进程还是线程

==多进程和多线程，这是实现多任务最常用的两种方式==。现在，我们来讨论一下这两种方式的优缺点。

首先，要实现多任务，通常我们会设计`Master-Worker`模式，Master 负责分配任务，Worker 负责执行任务，因此，多任务环境下，通常是一个 Master，多个 Worker。

如果用多进程实现`Master-Worker`，主进程就是 Master，其他进程就是 Worker。

如果用多线程实现`Master-Worker`，主线程就是 Master，其他线程就是 Worker。

- ==多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程==。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的 Apache 最早就是采用多进程模式。

- ==多进程模式的缺点是创建进程的代价大==，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。

- ==多线程模式通常比多进程快一点==，但是也快不到哪去，而且，==多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存==。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。

## 线程切换

无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？

操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。

所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。

## 计算密集型 vs. IO密集型

> I/O bound 指的是系统的CPU效能相对硬盘/内存的效能要好很多，此时，系统运作，大部分的状况是 CPU 在等 I/O (硬盘/内存) 的读/写，此时 CPU Loading 不高。CPU bound 指的是系统的 硬盘/内存 效能 相对 CPU 的效能 要好很多，此时，系统运作，大部分的状况是 CPU Loading 100%，CPU 要读/写 I/O (硬盘/内存)，I/O在很短的时间就可以完成，而 CPU 还有许多运算要处理，CPU Loading 很高。

是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和 IO 密集型。

计算密集型任务的特点是要进行大量的计算，消耗 CPU 资源，比如计算圆周率、对视频进行高清解码等等，全靠 CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU 执行任务的效率就越低，所以，要最高效地利用 CPU，计算密集型任务同时进行的数量应当等于 CPU 的核心数。

计算密集型任务由于主要消耗 CPU 资源，因此，代码运行效率至关重要。Python 这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用 C 语言编写。

第二种任务的类型是 IO 密集型，涉及到网络、磁盘 IO 的任务都是 IO 密集型任务，这类任务的特点是 CPU 消耗很少，任务的大部分时间都在等待IO操作完成（因为 IO 的速度远远低于 CPU 和内存的速度）。对于 IO 密集型任务，任务越多，CPU 效率越高，但也有一个限度。常见的大部分任务都是 IO 密集型任务，比如 Web 应用。

IO 密集型任务执行期间，99%的时间都花在 IO 上，花在 CPU 上的时间很少，因此，用运行速度极快的 C 语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。


## 异步 IO

考虑到 CPU 和 IO 之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待 IO 操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。

现代操作系统对 IO 操作已经做了巨大的改进，最大的特点就是支持异步 IO。如果充分利用操作系统提供的异步 IO支持，就可以==用单进程单线程模型来执行多任务==，这种全新的模型称为`事件驱动模型`，Nginx 就是支持异步 IO 的Web 服务器，它在单核 CPU上 采用单进程模型就可以高效地支持多任务。在多核 CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核 CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。

==对应到Python语言，单进程的异步编程模型称为协程==，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面讨论如何编写协程。


# 协程 (Coroutine)

==协程的特点在于是一个线程执行。==

协程是一个线程执行，那怎么利用多核 CPU 呢？==最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。==

协程主要有以下优势：

- 极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；
- 不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

Python 对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。

来看例子：

传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。

如果改用协程，生产者生产消息后，直接通过`yield`跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：

```python
import time

def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        time.sleep(1)
        r = '200 OK'

def produce(c):
    c.next()
    n = 0
    while n < 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

if __name__=='__main__':
    c = consumer()
    produce(c)
```

执行结果：

```python
[PRODUCER] Producing 1...
[CONSUMER] Consuming 1...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 2...
[CONSUMER] Consuming 2...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 3...
[CONSUMER] Consuming 3...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 4...
[CONSUMER] Consuming 4...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 5...
[CONSUMER] Consuming 5...
[PRODUCER] Consumer return: 200 OK
```

注意到 consumer 函数是一个 generator（生成器），把一个 consumer 传入 produce 后：

1. 首先调用 c.next() 启动生成器；

2. 然后，一旦生产了东西，通过 c.send(n) 切换到 consumer 执行；

3. consumer 通过 yield 拿到消息，处理，又通过 yield 把结果传回；

4. produce 拿到 consumer 处理的结果，继续生产下一条消息；

5. produce 决定不生产了，通过 c.close() 关闭 consumer，整个过程结束。

整个流程无锁，由一个线程执行，produce 和 consumer 协作完成任务，所以称为`协程`，而非线程的抢占式多任务。

最后套用Donald Knuth的一句话总结协程的特点：`子程序就是协程的一种特例。`


## gevent

Python 通过`yield`提供了对协程的基本支持，但是不完全。而第三方的 gevent 为 Python 提供了比较完善的协程支持。

使用gevent，可以获得极高的并发性能，但gevent只能在Unix/Linux下运行，在Windows下不保证正常安装和运行。

由于gevent是基于IO切换的协程，所以最神奇的是，我们编写的Web App代码，不需要引入gevent的包，也不需要改任何代码，仅仅在部署的时候，用一个支持gevent的WSGI服务器，立刻就获得了数倍的性能提升。具体部署方式可以参考后续“实战”-“部署Web App”一节。
















# 一个比喻

1. 单进程单线程：一个人在一个桌子上吃菜。
2. 单进程多线程：多个人在同一个桌子上一起吃菜。
3. 多进程单线程：多个人每个人在自己的桌子上吃菜。


多线程的问题是多个人同时吃一道菜的时候容易发生争抢，例如两个人同时夹一个菜，一个人刚伸出筷子，结果伸到的时候已经被夹走菜了。。。此时就必须等一个人夹一口之后，在还给另外一个人夹菜，也就是说资源共享就会发生冲突争抢。


有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。(廖雪峰的)


# 并发和并行

> 单核 CPU 在单一时间点只会执行一个线程

* 并行就是在同一个时间点执行多个任务，针对多核处理器
* 并发就是在一个时间间隔内执行多个任务，针对单核处理器，比如，杂技演员在空中抛球，接球



# 更多阅读

[多线程有什么用？ - 知乎](https://www.zhihu.com/question/19901763)

[怎样理解线程](http://xiaohuishu.net/2015/07/16/%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B/#java)

[理解进程和线程 | 张齐的博客](http://zq210wl.github.io/2015/01/03/computer-process-and-threads/)
[进程与线程的一个简单解释 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)

[](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868322563729e03f6905ea94f0195528e3647887415000)

